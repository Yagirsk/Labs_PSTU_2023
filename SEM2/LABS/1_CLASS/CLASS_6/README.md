# Лабораторная работа №6 "АТД. Контейнеры."

## Постановка задачи

1. Определить класс-контейнер.
2. Реализовать конструкторы, деструктор, операции ввода-вывода, операцию
присваивания.
3. Перегрузить операции, указанные в варианте.
4. Реализовать класс-итератор. Реализовать с его помощью операции
последовательного доступа.
5. Написать тестирующую программу, иллюстрирующую выполнение операций.

### 7 Вариант:

Класс-контейнер МНОЖЕСТВО с элементами типа int.

Реализовать операции:

- [] – доступа по индексу;
- int() – определение размера вектора;
- * – пересечение множеств;
- -- - переход к предыдущему элементу ( с помощью класса-итератора).

## UML-диаграмма

![uml](https://github.com/Yagirsk/Labs_PSTU_2023/blob/main/SEM2/LABS/1_CLASS/CLASS_6/images/class_6.drawio.png)

## Код программы

`Mnoz.h`
```cpp
#pragma once
#include <iostream>
using namespace std;
class Iterator
{
	friend class Mnoz;
public:
	Iterator() { elem = 0; }
	Iterator(const Iterator& it) { elem = it.elem; }
	bool operator ==(const Iterator& it) { return elem == it.elem; }
	bool operator !=(const Iterator& it) { return elem != it.elem; }
	void operator++() { elem++; };
	void operator--() { elem--; };
	int& operator*() const { return*elem; }
private:
	int* elem;
};
class Mnoz
{
public:
	Mnoz(int s, int k = 0);
	Mnoz(const Mnoz&m);
	~Mnoz();
	Mnoz& operator=(const Mnoz&m);
	int& operator[](int idx);
	Mnoz operator*(const Mnoz& m);
	int operator()();

	friend ostream& operator<<(ostream& out, const Mnoz& m);
	friend istream& operator>>(istream& in, Mnoz& m);

	Iterator first() { return beg; }
	Iterator last() { return end; }
private:
	int size;
	int* data;
	Iterator beg;
	Iterator end;
};

```

`Mnoz.cpp`
```cpp
#include "Mnoz.h"
Mnoz::Mnoz(int s, int k)
{
	size = s;
	data = new int[size];
	for (int i = 0; i < size; i++) { data[i] = k; }
	beg.elem = &data[0];
	end.elem = &data[size];
}
Mnoz::Mnoz(const Mnoz& m)
{
	size = m.size;
	data = new int[size];
	for (int i = 0; i < size; i++) { data[i] = m.data[i]; }
	beg = m.beg;
	end = m.end;
}
Mnoz::~Mnoz()
{
	delete[] data;
	data = 0;
}
Mnoz& Mnoz::operator=(const Mnoz&m)
{
	if (this == &m) { return*this; }
	size = m.size;
	if (data != 0) { delete[] data; }
	data = new int[size];
	for (int i = 0; i < size; i++) { data[i] = m.data[i]; }
	beg = m.beg;
	end = m.end;
	return *this;
}
int& Mnoz::operator[](int idx)
{
	if (idx < size) { return data[idx]; }
	else
	{
		cout << "Error, index > size \n";
	}
}
Mnoz Mnoz::operator*(const Mnoz& m)
{
	int* tmp_a = new int[0];
	int s = 0;
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < m.size; j++)
		{
			if (data[i] == m.data[j])
			{
				bool t = 1;
				for (int k = 0; k < s; k++)
				{
					if (tmp_a[k] == data[i]) { t = 0; }
				}
				if(t)
					tmp_a[s++] = data[i];
			}
		}
	}
	Mnoz mn(s);
	for (int i = 0; i < s; i++)
	{
		mn.data[i] = tmp_a[i];
	}
	return mn;
}
int Mnoz::operator()()
{
	return size;
}
ostream& operator<<(ostream& out, const Mnoz& m)
{
	for (int i = 0; i < m.size; i++)
		out << m.data[i] << " ";
	return out;
}
istream& operator>>(istream& in, Mnoz& m)
{
	for (int i = 0; i < m.size; i++)
	{
		cout << "Ýëåìåíò " << i << " = ";
		in >> m.data[i];
	}
	return in;
}
```

`class_6.cpp`
```cpp
﻿#include <iostream>
#include "Mnoz.h"
using namespace std;
int main()
{
	setlocale(LC_ALL, "ru_RU");
	Mnoz mnozvo(5);
	cout << mnozvo << endl;
	cin >> mnozvo;
	cout << mnozvo << endl;
	mnozvo[1] = 333;
	cout << mnozvo << endl;

	Mnoz mnozo(10);
	cout << mnozo << endl;
	mnozo = mnozvo;
	cout << mnozo << endl;
	cin >> mnozo;
	Mnoz tmp = mnozvo * mnozo;
	cout << tmp << endl;
	cout << "Длинна множества mnozvo " << mnozvo() << endl;

	cout << *(mnozvo.first()) << endl;
	Iterator i = mnozvo.first();
	++i;
	cout << *i << endl;
	for (i = mnozvo.first(); i != mnozvo.last(); ++i)
	{
		cout << *i << " ";
	}

}
```

## Тесты скриншоты

<image src ="https://github.com/Yagirsk/Labs_PSTU_2023/blob/main/SEM2/LABS/1_CLASS/CLASS_6/images/изображение_2024-04-22_161920773.png">

## Ответы на вопросы

**1. Что такое абстрактный тип данных? Привести примеры АТД.**

`Абстрактный тип данных (АТД) - это математическая модель для типов данных, где тип данных определяется его поведением (семантикой) с точки зрения пользователя данных, в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций. Примеры АТД: стек, очередь, список, множество.`

**2. Привести примеры абстракции через параметризацию.**

`Абстракция через параметризацию позволяет определить структуру, которая может работать с любым типом данных. Примером может служить шаблон класса, где тип данных, с которым должен работать класс, является параметром.`

**3. Привести примеры абстракции через спецификацию.**

`Абстракция через спецификацию включает определение общего интерфейса, который может быть реализован различными способами. Например, интерфейс списка, который может быть реализован как связный список или массив.`

**4. Что такое контейнер? Привести примеры.**

`Контейнер в программировании - это тип, позволяющий инкапсулировать в себе объекты других типов. Примеры контейнеров: vector, list, map.`

**5. Какие группы операций выделяют в контейнерах?**

`В контейнерах выделяют группы операций для добавления, удаления и доступа к элементам, а также операции для работы с размером и состоянием контейнера.`

**6. Какие виды доступа к элементам контейнера существуют? Привести примеры.**

`Произвольный доступ (random access): например, доступ по индексу в массиве или векторе.`
`Последовательный доступ (sequential access): например, перебор элементов с помощью итераторов в списке.`

**7. Что такое итератор?**

`Итератор - это объект, который позволяет перебирать элементы контейнера и предоставляет доступ к каждому элементу в коллекции.`

**8. Каким образом может быть реализован итератор?**

`Итератор может быть реализован как объект с методами для перемещения по контейнеру (например, используя инкрементацию и декрементацию) и получения доступа к элементам. Чтобы понимать границы контейнера, они могут прописываться в нем самом.`

**9. Каким образом можно организовать объединение контейнеров?**

`Объединение контейнеров может быть организовано с помощью создания нового контейнера, который включает в себя элементы исходных контейнеров, также можно сортировать контейнеры при объединении или брать одинаковые элементы только по одному экземпляру, или, вовсе, брать только элементы содержащиеся в обоих изначальных контейнерах. Все зависит от конкретного условия. Для организации удобно использовать перегрузку бинарных операторов.`

**10. Какой доступ к элементам предоставляет контейнер, состоящий из элементов «ключ-значение»?**

`Контейнер, состоящий из элементов «ключ-значение» (например, map), предоставляет доступ к элементам через ключ.`

**11. Как называется контейнер, в котором вставка и удаление элементов выполняется на одном конце контейнера?**

`Контейнер, в котором вставка и удаление элементов выполняется на одном конце, называется стек (stack).`

**12. Какой из объектов (a,b,c,d) является контейнером?**

- a. int mas = 10;
- b. int mas;
- c. struct {char name[30]; int age;} mas;
- d. int mas[100].

`Из предложенных объектов контейнером является d. int mas[100]; - это массив, который может содержать до 100 элементов типа int.`

**13. Какой из объектов (a,b,c,d) не является контейнером?**
- a. int a[] = {1,2,3,4,5};
- b. int mas[30];
- c. struct {char name[30]; int age;} mas[30];
- d. int mas.

`Объект, который не является контейнером: d. 4. int mas; - это объявление переменной без инициализации массива или структуры.`

**14. Контейнер реализован как динамический массив, в нем определена операция доступ по индексу. Каким будет доступ к элементам контейнера?**

`Если контейнер реализован как динамический массив с операцией доступа по индексу, то доступ к элементам будет произвольным.`

**15. Контейнер реализован как линейный список. Каким будет доступ к элементам контейнера?**

`Если контейнер реализован как линейный список, то доступ к элементам будет последовательным.`
