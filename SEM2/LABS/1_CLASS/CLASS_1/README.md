# Лабораторная работа №1 "Классы и объекты. Инкапсуляция."

## Постановка задачи

1. Реализовать определение нового класса. Для демонстрации работы с объектами написать главную функцию. Продемонстрировать разные способы создания объектов и массивов объектов.
2. Структура - пара - структура с двумя полями, которые обычно имеют имена first и second. Требуется реализовать тип данных с помощью такой структуры.Во всех заданиях должны присутствовать:
	a. метод инициализации Init (метод должен контролировать значения аргументов на корректность);
	b. ввод с клавиатуры Read;
	c. вывод на экран Show.
3. Реализовать внешнюю функцию make тип(), где тип - тип реализуемой структуры.Функция должна получать значения для полей структуры как параметры функции и возвращать структуру как результат. При передаче ошибочых параметров следует выводить сообщение и заканчивать работу.

### 7 Вариант:

Линейное уравнение у=Ax+В. Поле first - дробное число, коэффициент А, поле second - дробное число, коэффициент B. Реализовать метод function(double x) - вычисление значения у для заданного х.

## UML-диаграмма

<image src ="https://github.com/Yagirsk/Labs_PSTU_2023/blob/main/SEM2/LABS/1_CLASS/CLASS_1/images/class_1.drawio.png">

## Код программы

~~~
﻿#include <iostream>
#include <string>
#include "Header.h"
#include <sstream>
using namespace std;
int main()
{
	setlocale(LC_ALL, "ru_RU");
	string end_if;
	cout << "Введите 'Panzerselbstfahrlafette' если хотите прекратить выполнение работы программы: ";
	cin >> end_if;
	if (end_if == "Panzerselbstfahrlafette")
	{
		return 0;
	}


	linear_ur urav;
	urav.init();
	urav.read();
	if (urav.r == 1)
	{
		urav.show();

		cout << "Введите x: ";
		string x_r;
		cin >> x_r;
		if (urav.isFloat(x_r))
		{
			float x_x = stof(x_r);
			urav.function(x_x);
		}
		else { cout << "Некорректное значение x\n"; }

	}
	else { cout << "Некорректное значение одной или обеих переменных\n"; }


	system("pause");
	main();
}
~~~

~~~
#ifndef HEADER_H
#define HEADER_H

class linear_ur
{
private:
	float y;
	float x;
	float B;
	float A;
public:
	bool r;
	void init();
	void read();
	bool isFloat(const std::string& input);
	void show();
	void function(float x_X);
};

#endif
~~~

~~~
#include <iostream>
#include <string>
#include <sstream>
#include "Header.h"
using namespace std;
void linear_ur::init()
{
	y = 0;
	x = 0;
	B = 0;
	A = 0;
	r = 1;
}
void linear_ur::read()
{
	//r = 1;
	string A_r, B_r;
	cout << "Ââåäèòå êîýôôèöåíòû A è B ñîîòâåòñòâåííî: ";
	cin >> A_r;
	cin >> B_r;
	if (isFloat(A_r))
	{
		A = stof(A_r);
	}
	else { r = 0; }

	if (isFloat(B_r))
	{
		B = stof(B_r);
	}
	else { r = 0; }
}
bool linear_ur::isFloat(const string& input)
{
	istringstream ss(input);
	float value;
	ss >> noskipws >> value;
	return ss.eof() && !ss.fail();
}
void linear_ur::show()
{
	if (B > 0)
	{
		cout << "y = " << A << "x" << " + " << B << endl;
	}
	else if (B == 0)
	{
		cout << "y = " << A << "x" << endl;
	}
	else
	{
		cout << "y = " << A << "x" << " - " << abs(B) << endl;
	}
}
void linear_ur::function(float x_X)
{
	x = x_X;
	y = A * x + B;
	cout << "y = " << y << endl;
	
}
~~~

## Тесты

<image src ="https://github.com/Yagirsk/Labs_PSTU_2023/blob/main/SEM2/LABS/1_CLASS/CLASS_1/images/изображение_2024-04-09_120745898.png">

## Ответы на вопросы

1. **Что такое класс?**

`Класс - это шаблон или чертеж, определяющий свойства (атрибуты) и поведение (методы) определенного типа объектов`.

2. **Что такое объект (экземпляр) класса?**

`Объект (экземпляр) класса - это конкретный экземпляр класса, который имеет состояние и поведение, определенное классом`.

3. **Как называются поля класса?**

`Поля класса (или атрибуты) - это переменные, которые хранят состояние объекта`.

4. **Как называются функции класса?**

`Функции класса (или методы) - это функции, которые определяют поведение объекта`.

5. **Для чего используются спецификаторы доступа?**

`Спецификаторы доступа используются для определения области видимости полей и методов класса`.

6. **Для чего используется спицификатор public?**

`Public - это спецификатор доступа, который позволяет доступ к полям и методам класса из любого места в коде`.

7. **Для чего используется спецификатор private?**

`Private - это спецификатор доступа, который ограничивает доступ к полям и методам класса только внутри самого класса`.

8. **Если описание  класса начинается со спецификатора class, то какой спецификатор доступа будет по умолчанию?**

`Если описание класса начинается со спецификатора class, то спецификатор доступа по умолчанию будет private`.

9. **Если описание  класса начинается со спецификатора struct, то какой спецификатор доступа будет по умолчанию?**

`Если описание класса начинается со спецификатора struct, то спецификатор доступа по умолчанию будет public`.

10. **Какой спецификатор доступа должен испольщоваться при описании интерфейса класса? Почему?**

`При описании интерфейса класса обычно используется спецификатор доступа public, потому что интерфейс предназначен для взаимодействия с другими частями кода`.

11. **Каким образом можно изменить значения атрибутов экземпляра класса?**

`Значения атрибутов экземпляра класса можно изменить, обратившись к ним напрямую (если они public) или через методы класса (getters и setters)`.

12. **Каким образом можно получить значения атрибутов экземпляра класса?**

`Значения атрибутов экземпляра класса можно получить, обратившись к ним напрямую (если они public) или через методы класса (getters)`.

13. **Класс описан следующим образом:**
```cpp
struct Student
{
	string name;
	int group;
};
```
**Объект класса определен следующим образом:**
```cpp
Student *s = new Student;
```
**Как можно обратиться к полю `name` объекта `s`?**

`s->name`.

14. **Класс описан следующим образом:**
```cpp
struct Student
{
	string name;
	int group;
};
```
**Объект класса определен следующим образом:**
```cpp
Student s;
```
**Как можно обратиться к полю `name` объекта `s`?**

`s.name`.

15. **Класс описан следующим образом:**
```cpp
class Student
{
	string name;
	int group;
};
```
**Объект класса определен следующим образом:**
```cpp
Student *s = new Student;
```
**Как можно обратиться к полю `name` объекта `s`?**

`Ответ: Так как поле name явлется private, нужно написать геттер, после чего можно получить доступ вот так: s->getName(), ниже пример реализации:`
```cpp
class Student
{
    string name;
    int group;
public:
    string getName()
    {
        return name;
    }
};

Student *s = new Student;
string studentName = s->getName();
```

16. **Класс описан следующим образом:**
```cpp
class Student
{
	string name;
	int group;
};
```
**Объект класса определен следующим образом:**
```cpp
Student s;
```
**Как можно обратиться к полю `name` объекта `s`?**

`Ответ: Так как поле name явлется private, нужно написать геттер, после чего можно получить доступ вот так: s.getName(), ниже пример реализации:`
```cpp
class Student
{
    string name;
    int group;
public:
    string getName()
    {
        return name;
    }
};

Student s;
string studentName = s.getName();
```

17. **Класс описан следующим образом:**
```cpp
class Student
{
public:
	char* name;
	int group;
};
```
**Объект класса определен следующим образом:**
```cpp
Student *s = new Student;
```
**Как можно обратиться к полю `name` объекта `s`?**

`Ответ: Так как мы точно не знаем, на что указывает char* name, предположим, что он указывает на реально существующую строку (массив символов, ведь имя не состоит из одного символа), тогда получить строку можно так:`
```cpp
class Student
{
public:
	char* name;
    int group;
};

Student *s = new Student;
char* nameAddress = s->name;
string studentName = nameAddress; // предполагая, что name - указатель массива символов, поэтому данная операция просто присвоит строке массив символов (но желательно знать размер)
```
