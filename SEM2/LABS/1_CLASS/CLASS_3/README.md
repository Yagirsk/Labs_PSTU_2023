# Лабораторная работа №3 "Перегрузка операций"

## Постановка задачи

1. Определить пользовательский класс.
2. Определить в классе следующие конструкторы: без параметров, с параметрами,
копирования.
3. Определить в классе деструктор.
4. Определить в классе компоненты-функции для просмотра и установки полей
данных (селекторы и модификаторы).
5. Перегрузить операцию присваивания.
6. Перегрузить операции ввода и вывода объектов с помощью потоков.
7. Перегрузить операции указанные в варианте.
8. Написать программу, в которой продемонстрировать создание объектов и работу
всех перегруженных операций.

### 7 Вариант:

Создать класс Money для работы с денежными суммами. Число должно быть представлено двумя полями: типа long для рублей и типа int для копеек. Дробная часть числа при выводе на экран должна быть отделена от целой части запятой. Реализовать:
 - деление сумм;
 - умножение суммы на дробное число.

## UML-диаграмма

<image src ="https://github.com/Yagirsk/Labs_PSTU_2023/blob/main/SEM2/LABS/1_CLASS/CLASS_3/images/class_3.drawio.png">

## Код программы

~~~
﻿#include <iostream>
#include "Header.h"
using namespace std;
int main()
{
	setlocale(LC_ALL, "ru_RU");
	money m_1;
	money m_2;
	money m_3;
	money m_4;
	cin >> m_1;
	cin >> m_2;
	cin >> m_3;
	cin >> m_4;
	cout << "m_1 = " << m_1 << endl;
	cout << "m_2 = " << m_2 << endl;
	cout << "m_3 = " << m_3 << endl;
	cout << "m_4 = " << m_4 << endl;

	cout << "m_1 / m_2 = " << m_1 / m_2 << endl;

	float m;
	cout << "Введите число на которое будет умножено m_3: ";
	cin >> m;
	m_3 = m_3 * m;
	cout << "m_3 = " << m_3 << endl << endl;

	cout << "Введите число на которое будет поделено m_4: ";
	cin >> m;
	m_4 = m_4 / m;
	cout << "m_4 = " << m_4 << endl << endl;
}
~~~

~~~
#pragma once
#include <iostream>
using namespace std;
class money
{
private:
	long rub;
	int kop;
public:
	money() { rub = 0, kop = 0; }
	money(long r, int k) { rub = r, kop = k; }
	money(const money& t) { rub = t.rub, kop = t.kop; }
	~money() {}
	long get_rub() { return rub; }
	int get_kop() { return kop; }
	void set_rub(long n_rub) { rub = n_rub; }
	void set_rub(int n_kop) { kop = n_kop; }
	money& operator=(const money&);
	money operator*(float m);
	float operator/(const money&);
	money operator/(float m);
	friend istream& operator>>(istream& in, money& t);
	friend ostream& operator<<(ostream& out, const money& t);
};
~~~

~~~
#include <iostream>
#include "Header.h"
#define GET_VARIABLE_NAME(Variable) #Variable
using namespace std;
money& money::operator=(const money& t)
{
	if (&t == this) { return *this; }
	rub = t.rub;
	kop = t.kop;
	return *this;
}
money money::operator*(float m)
{
	int tmp_1 = rub * 100 + kop;
	tmp_1 *= m;
	money p;
	p.rub = tmp_1 / 100;
	p.kop = tmp_1 % 100;
	return p;
}
float money::operator/(const money& m)
{
	float tmp_1 = rub * 100 + kop;
	float tmp_2 = m.rub * 100 + m.kop;
	float p = tmp_1 / tmp_2;
	return p;
}
money money::operator/(float m)
{
	float tmp_1 = rub * 100 + kop;
	money p;
	tmp_1 /= m;
	int t = tmp_1;
	p.rub = t / 100;
	p.kop = t % 100;
	return p;
}
istream& custom_input(istream& in, money& m, const char* name)
{
	int tmp;
	cout << "Введите рубли для переменной " << name << ": "; in >> m.rub;
	cout << "Введите копейки для переменной " << name << ": "; in >> tmp;
	if (tmp >= 100)
	{
		m.kop = tmp % 100;
		m.rub += tmp / 100;
	}
	else
	{
		m.kop = tmp;
	}
	return in;
}
ostream& operator <<(ostream& out, const money& m)
{
	if (m.kop<10){ return (out << m.rub << ",0" << m.kop); }
	return (out << m.rub << "," << m.kop);
}
~~~

## Тесты скриншоты

<image src ="https://github.com/Yagirsk/Labs_PSTU_2023/blob/main/SEM2/LABS/1_CLASS/CLASS_3/images/изображение_2024-04-09_121309143.png">

## Ответы на вопросы

**1. Для чего используются дружественные функции и классы?**

`Дружественные функции и классы в C++ используются для предоставления доступа к закрытым (private) членам другого класса.`

`Дружественные функции не являются членами класса, но имеют доступ к его приватным переменным и функциям.`

`Для определения дружественных функций используется ключевое слово friend.`

**2. Сформулировать правила описания и особенности дружественных функций.**

`Дружественные функции могут быть определены внутри класса или в другом классе`.

`Для них не важно, определены ли они под спецификатором public или private`.

`Они имеют доступ ко всем членам класса, включая закрытые.`

**3. Каким образом можно перегрузить унарные операции?**

`Унарные операции могут быть перегружены для пользовательских типов данных (классов).`

`Для перегрузки унарных операций используются специальные методы класса (например, operator+, operator-, operator++, operator--, они были применены в этой лабораторной работе).`

`При перегрузки оператора мы можем заставить его выполнять какие угодно действия над объектом нашего класса`

**4. Сколько операндов должна иметь унарная функция-операция, определяемая внутри класса?**

`Унарная функция-операция, определенная внутри класса, должна иметь от нуля до одного операнда (параметра) в явном виде, так как объект класса в данном случае передаётся неявно, как this.`

**5. Сколько операндов должна иметь унарная функция-операция, определяемая вне класса?**

`Унарная функция-операция, определенная вне класса, должна иметь один операнд в явном виде, так как она не получает this.`

**6. Сколько операндов должна иметь бинарная функция-операция, определяемая внутри класса?**

`Бинарная функция-операция, определенная внутри класса, должна иметь один-два операнда (параметра) в явном виде по причинам, описанным выше.`

**7. Сколько операндов должна иметь бинарная функция-операция, определяемая вне класса?**

`Бинарная функция-операция, определенная вне класса, должна иметь два операнда в явном виде, так как она не получает this.`

**8. Чем отличается перегрузка префиксных и постфиксных унарных операций?**

`Префиксная форма (например, ++x) возвращает измененное значение до выполнения операции.`
`Постфиксная форма (например, x++) возвращает исходное значение, а затем выполняет операцию.`
`При перегрузке постфиксного оператора важно писать в круглых скобках int, например, operator--(int).`

**9. Каким образом можно перегрузить операцию присваивания?**

`Операция присваивания (=) может быть перегружена для пользовательских типов данных. Для этого используется метод operator= внутри класса.`

**10. Что должна возвращать операция присваивания?**

`Операция присваивания (=) должна возвращать ссылку на объект, чтобы обеспечить возможность цепочки присваиваний (например, a = b = c = 42;).`

**11. Каким образом можно перегрузить операции ввода-вывода?**

`Перегрузка операций ввода-вывода в C++ позволяет пользовательским типам данных (классам) определить собственное поведение при вводе и выводе объектов. Для этого используются методы operator>> и operator<<. Для корректной работы перегрузку надо описывать вне класса, как дружественную функцию. Примером использования служит данная лабораторная работа.`

**12. В программе описан класс**
```cpp
class Student
{
	Student& operator++();
};
```
**и определен объект этого класса**
```cpp
Student s;
```
**Выполняется операция**
```cpp
++s;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`В данном случае, компилятор будет воспринимать вызов функции-операции префиксного инкремента (++s) следующим образом:`

`Оператор ++ будет применяться к объекту s, вызывая метод operator++() внутри класса Student.`

`Метод operator++() должен изменить состояние объекта s и вернуть ссылку на него (тип Student&).`

**13. В программе описан класс**
```cpp
class Student
{
	friend Student& operator ++( Student&);
};
```
**и определен объект этого класса**
```cpp
Student s;
```
**Выполняется операция**
```cpp
++s;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`Если оператор ++ перегружен как дружественная функция, то компилятор будет воспринимать вызов следующим образом:`

`Оператор ++ будет применяться к объекту s, вызывая дружественную функцию operator++(Student&).`

`Дружественная функция operator++(Student&) также должна изменить состояние объекта s и вернуть ссылку на него.`

14. В программе описан класс
```cpp
class Student
{
	bool operator<(Student &P);
};
```
**и определены объекты этого класса**
```cpp
Student a,b;
```
**Выполняется операция**
```cpp
cout << a < b;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`В данном случае, компилятор будет воспринимать вызов оператора сравнения следующим образом:`

`Оператор < будет применяться к объектам a и b, вызывая метод operator<(Student&) внутри класса Student.`

`Метод operator<(Student&) должен вернуть true или false в зависимости от результата сравнения.`

`При выводе булевых значений в консоль они выводятся как 0 или 1`

**15. В программе описан класс**
```cpp
class Student
{
	friend bool operator >(const Person&, Person&)
};
```
**и определены объекты этого класса**
```cpp
Student a,b;
```
**Выполняется операция**
```cpp
cout << a > b;
```
**Каким образом, компилятор будет воспринимать вызов функции-операции?**

`Если оператор > перегружен как дружественная функция, то компилятор будет воспринимать вызов следующим образом:`

`Оператор > будет применяться к объектам a и b, вызывая дружественную функцию operator>(const Student&, Student&).`

`Дружественная функция operator>(const Student&, Student&) также должна вернуть true или false.`

`При выводе булевых значений в консоль они выводятся как 0 или 1`
